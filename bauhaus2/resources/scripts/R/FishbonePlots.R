#!/usr/bin/env Rscript
# Fit a constant rate arrow model to an alignment/reference and output the
# parameters as a CSV
# Make finshbone plots from a csv file generated by fitting hmm model
# This script combines constant_arrow.R and FishbonePlotsCmdLine.R

library(argparse)
library(data.table, quietly = TRUE)
library(jsonlite, quietly = TRUE)
library(logging)
library(ggplot2)
library(pbbamr)
library(uuid, quietly = TRUE)
library(gridExtra)
library(dplyr, quietly = TRUE)
library(tidyr, quietly = TRUE)
library(unitem)
library(nnet)
library(reshape2)
library(lazyeval)

## FIXME: make a real package
myDir = "./scripts/R"
source(file.path(myDir, "Bauhaus2.R"))

# Define a basic addition to all plots
plTheme <- theme_bw(base_size = 18)
clScale <- scale_colour_brewer(palette = "Set1")
clFillScale <- scale_fill_brewer(palette = "Set1")
themeTilt = theme(axis.text.x = element_text(size = 11, angle = 45, hjust = 1))
pd <- position_dodge(0.2)
dpi <- 72

makeFishbonePlots <- function(errormodeMerge, report, minSample = 20) {
  loginfo("making fishbone plots.")
  
  # some functions
  concat <- function(...) paste(..., sep = "")
  nam <- function(...) as.name(concat(...))
  
  breaks = c(0, 1:40)/2
  bases <- c("A", "C", "G", "T")
  
  massage <- function(df, channel) {
    # filter on data specifically under the expectation of the channel base
    ch <- concat(channel, ".")
    re <- concat("^", channel, "\\.")
    df <- df %>%
      dplyr::select(ZMW, starts_with("SNR."), starts_with(ch)) %>%
      dplyr::rename_(.dots = setNames(names(.), gsub(re, "", names(.))))
    
    ci95 <- function(var) interp(~ sd(x)/sqrt(n()) * qt(0.975, n() - 1), x = lazy(var))
    mvNams <- function(b, moves) unlist(lapply(c(moves), function(x) concat(x, ".", b)))
    stNams <- function(b, moves) unlist(lapply(c(moves), function(x) concat(x, ".", b, ".", c("mu", "ci"))))
    
    # collect the results for each outcome base
    dfCh <- NULL
    
    for (b in bases) {
      # get the transition moves under the regime of expectedBase:observedBase
      moves <- gsub(".[ACGT]$", "", colnames(dplyr::select(df, ends_with(concat(".", b)), -starts_with("SNR"))))
      
      # get the raw move names
      nms <- mvNams(b, moves)
      
      # prepare the mean- and 95%ci-accumulating functions
      mus <- lapply(nms, function(x) interp(~ mean(y), y = as.name(x)))
      cis <- lapply(nms, function(x) eval(interp(ci95(y), y = as.name(x))))
      
      # create the interleaved list of mean- and 95%ci-accumulating functions
      obj <- c(rbind(mus, cis))
      
      # get the names of the statistical variables
      nms <- stNams(b, moves)
      
      # add the number of observations to the list of variables (for later filtering)
      obj <- c(obj, ~ n())
      nms <- c(nms, "N")
      
      # group the samples by their SNR bin and collect summary mean and 95%ci
      suppressWarnings({
        dfStats <- df %>%
          dplyr::select(ZMW, ends_with(concat(".", b))) %>%
          dplyr::mutate_(snr = interp(~ cut(x, breaks), x = nam("SNR.", b))) %>%
          dplyr::select(-starts_with("SNR.")) %>%
          dplyr::group_by(snr) %>%
          dplyr::summarize_(.dots = setNames(obj, nms)) %>%
          dplyr::ungroup()
      })
      
      # melt the data on which move and accumulate
      dfObs <- NULL
      
      for (mv in moves) {
        dfMv <- dfStats %>%
          dplyr::select(snr, starts_with(mv), N) %>%
          dplyr::rename_(.dots = setNames(names(.), gsub(concat(mv, "\\.", b, "\\."), "", names(.)))) %>%
          dplyr::mutate(move = mv)
        dfObs <- rbind(dfObs, dfMv)
      }
      
      dfObs$obs <- b
      dfCh <- rbind(dfCh, dfObs)
    }
    
    dfCh$exp <- channel
    dfCh
  }
  
  # collect the results over each expected match base
  dfErr = list()
  
  readcondition = errormodeMerge$Condition
  for (i in 1:length(readcondition)) {
    dfErr[[i]] = NA
    for (b in bases) {
      dfErr[[i]] <- rbind(dfErr[[i]], massage(errormodeMerge[errormodeMerge$Condition == readcondition[i],], b))
      dfErr[[i]] = dfErr[[i]][c(2:nrow(dfErr[[i]])),]
    }
    # make sure things are factors and the appropriate levels
    levels(dfErr[[i]]$snr) <- head(breaks, length(levels(dfErr[[i]]$snr)))
    dfErr[[i]]$move <- as.factor(dfErr[[i]]$move)
    dfErr[[i]]$exp <- as.factor(dfErr[[i]]$exp)
    dfErr[[i]]$obs <- as.factor(dfErr[[i]]$obs)
    dfErr[[i]] <- as.data.frame(dfErr[[i]])
    row.names(dfErr[[i]]) <- seq.int(nrow(dfErr[[i]]))
    # Add Condition name from the input file names
    dfErr[[i]]$Condition = readcondition[i]
  }
  # write the data
  dfErr = do.call(rbind, dfErr)
  report$write.table("FishboneSnrBinnedSummary.csv",
                     dfErr,
                     id = "fishbone_snr_binned_summary",
                     title = "Fishbone Snr Binned Summary")
  
  ## WRITE THE PLOTS ##
  # filter by min number of samples in each SNR bin
  dfErr_ <- dfErr %>% filter(N >= minSample)
  loginfo("filtered %d of %d samples", nrow(dfErr) - nrow(dfErr_), nrow(dfErr))
  if (nrow(dfErr_) == 0) {
    stop("You have filtered out all of your data and need to increase the Min Sample!")
  }
  
  t <- function(mv) ifelse(mv == "Match", "Mismatch", as.character(mv))
  
  dfErr_ <- dfErr_ %>%
    dplyr::mutate(exp_ = concat("NextBase - ", exp), obs_ = concat(t(move), " - ", obs))
  dfErr_$exp_ <- as.factor(dfErr_$exp_)
  dfErr_$obs_ <- as.factor(dfErr_$obs_)
  
  limits <- function(df) {
    m <- floor(min(df$mu - df$ci) * 50) / 50
    M <- ceiling(max(df$mu + df$ci) * 50) / 50
    c(m, M)
  }
  
  labelFn <- function(x) { sprintf("%0.2f", x) }
  breaksFn <- function(x) { seq(x[[1]], x[[2]], by = 0.02)}
  
  dfIns <- dfErr_ %>% filter(move == "Insert")
  ylim <- limits(dfIns)
  breaks <- breaksFn(ylim)
  tp = ggplot(dfIns, aes(x = as.numeric(as.character(snr)), y = mu, group = Condition, colour = Condition)) +
    geom_point(aes(colour = Condition)) + geom_line(aes(colour = Condition)) + geom_errorbar(aes(ymin = mu - ci, ymax = mu + ci, colour = Condition), width = 0.1, position = pd) +
    xlim(0, 20) + scale_y_continuous(limits = ylim, breaks = breaks) +
    labs(x = "SNR by Outcome", y = "HMM Insertion Error") +
    facet_grid(exp_ ~ obs_) +
    plTheme + clScale + themeTilt
  report$ggsave(
    "fishboneplot_insertion.png",
    tp,
    id = "fishboneplot_insertion",
    title = "FishbonePlot - Insertion",
    caption = "FishbonePlot - Insertion",
    tags = c("fishbone", "hmm", "errormode", "insertion")
  )
  
  dfMM <- dfErr_ %>% filter(move == "Match" & obs != exp)
  ylim <- limits(dfMM)
  breaks <- breaksFn(ylim)
  tp = ggplot(dfMM, aes(x = as.numeric(as.character(snr)), y = mu, group = Condition, colour = Condition)) +
    geom_point(aes(colour = Condition)) + geom_line(aes(colour = Condition)) + geom_errorbar(aes(ymin = mu - ci, ymax = mu + ci, colour = Condition), width = 0.1, position = pd) +
    xlim(0, 20) + scale_y_continuous(limits = ylim, breaks = breaks) +
    labs(x = "SNR by Outcome", y = "HMM Mismatch Error") +
    facet_grid(exp_ ~ obs_) +
    plTheme + clScale + themeTilt
  report$ggsave(
    "fishboneplot_mismatch.png",
    tp,
    id = "fishboneplot_mismatch",
    title = "FishbonePlot - MisMatch",
    caption = "FishbonePlot - MisMatch",
    tags = c("fishbone", "hmm", "errormode", "mismatch")
  )
  
  dfDel <- dfErr_ %>% filter(move == "Dark" | move == "Merge")
  ylim <- limits(dfDel)
  breaks <- breaksFn(ylim)
  tp = ggplot(dfDel, aes(x = as.numeric(as.character(snr)), y = mu, colour = Condition, group = Condition)) +
    geom_point(aes(colour = Condition)) + geom_line(aes(colour = Condition)) + geom_errorbar(aes(ymin = mu - ci, ymax = mu + ci, colour = Condition), width = 0.1, position = pd) +
    xlim(0, 20) + scale_y_continuous(limits = ylim, breaks = breaks) +
    labs(x = "SNR by Event", y = "HMM Deletion Error") +
    facet_grid(exp_ ~ move) +
    plTheme + clScale + themeTilt
  report$ggsave(
    "fishboneplot_deletion.png",
    tp,
    id = "fishboneplot_deletion",
    title = "FishbonePlot - Deletion",
    caption = "FishbonePlot - Deletion",
    tags = c("fishbone", "hmm", "errormode", "deletion")
  )
  
  dfErr
}

makeReport <- function(report) {
  
  conditions = report$condition.table
  n = length(levels(conditions$Condition))
  clFillScale <<- getPBFillScale(n)
  clScale <<- getPBColorScale(n)
  
  # Load csv files
  errormodeMerge = read.csv("reports/ConstantArrowFishbonePlots/errormode.csv")
  # Make Fishbone Plots
  makeFishbonePlots(errormodeMerge, report)
  
  # Save the report object for later debugging
  save(report, file = file.path(report$outputDir, "report.Rd"))
  
  # At the end of this function we need to call this last, it outputs the report
  report$write.report()
}

main <- function()
{
  report <- bh2Reporter(
    "condition-table.csv",
    "reports/ConstantArrowFishbonePlots/report.json",
    "Constant Arrow Fishbone Plots")
  makeReport(report)
  0
}

## Leave this as the last line in the file.
logging::basicConfig()
main()
