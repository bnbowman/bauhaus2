#!/usr/bin/env Rscript
# Make finshbone plots from a csv file generated by fitting hmm model

suppressPackageStartupMessages({
  library(argparse)
  library(reshape2)
  library(ggplot2)
  library(dplyr)
  library(tidyr)
  library(gridExtra)
  library(logging)
  library(lazyeval)
})

logging::basicConfig()

parser <- ArgumentParser()

parser$add_argument("inputs",  nargs = '+', help = "CSV files with fits")
parser$add_argument("--conditionNames",  nargs = 1, type = "character", default = "", help = "condition names for each csv file, sep by ','")
parser$add_argument("--minSample", nargs = 1, default = 20, help = "minimum number of samples required for each estimate")
parser$add_argument("--output", nargs = 1, default = getwd(), help = "output file folder")
parser$add_argument("--seed", nargs = 1, type = "integer", default = 42, help = "seed value for set.seed")
try(args <- parser$parse_args())
set.seed(args$seed)

# Define a basic addition to all plots
plTheme <- theme_bw(base_size = 18)
clScale <- scale_colour_brewer(palette = "Set1")
clFillScale <- scale_fill_brewer(palette = "Set1")
themeTilt = theme(axis.text.x = element_text(size = 11, angle = 45, hjust = 1))
pd <- position_dodge(0.2)
dpi <- 72

makeFishbonePlots <- function(errormode, output_path, minSample = 20) {
  loginfo("making fishbone lots in: '%s'", output_path)

  # some functions
  concat <- function(...) paste(..., sep = "")
  nam <- function(...) as.name(concat(...))

  breaks = c(0, 1:40)/2
  bases <- c("A", "C", "G", "T")

  massage <- function(df, channel) {
    # filter on data specifically under the expectation of the channel base
    ch <- concat(channel, ".")
    re <- concat("^", channel, "\\.")
    df <- df %>%
      dplyr::select(ZMW, starts_with("SNR."), starts_with(ch)) %>%
      dplyr::rename_(.dots = setNames(names(.), gsub(re, "", names(.))))

    ci95 <- function(var) interp(~ sd(x)/sqrt(n()) * qt(0.975, n() - 1), x = lazy(var))
    mvNams <- function(b, moves) unlist(lapply(c(moves), function(x) concat(x, ".", b)))
    stNams <- function(b, moves) unlist(lapply(c(moves), function(x) concat(x, ".", b, ".", c("mu", "ci"))))

    # collect the results for each outcome base
    dfCh <- NULL

    for (b in bases) {
      # get the transition moves under the regime of expectedBase:observedBase
      moves <- gsub(".[ACGT]$", "", colnames(dplyr::select(df, ends_with(concat(".", b)), -starts_with("SNR"))))

      # get the raw move names
      nms <- mvNams(b, moves)

      # prepare the mean- and 95%ci-accumulating functions
      mus <- lapply(nms, function(x) interp(~ mean(y), y = as.name(x)))
      cis <- lapply(nms, function(x) eval(interp(ci95(y), y = as.name(x))))

      # create the interleaved list of mean- and 95%ci-accumulating functions
      obj <- c(rbind(mus, cis))

      # get the names of the statistical variables
      nms <- stNams(b, moves)

      # add the number of observations to the list of variables (for later filtering)
      obj <- c(obj, ~ n())
      nms <- c(nms, "N")

      # group the samples by their SNR bin and collect summary mean and 95%ci
      suppressWarnings({
        dfStats <- df %>%
          dplyr::select(ZMW, ends_with(concat(".", b))) %>%
          dplyr::mutate_(snr = interp(~ cut(x, breaks), x = nam("SNR.", b))) %>%
          dplyr::select(-starts_with("SNR.")) %>%
          dplyr::group_by(snr) %>%
          dplyr::summarize_(.dots = setNames(obj, nms)) %>%
          dplyr::ungroup()
      })

      # melt the data on which move and accumulate
      dfObs <- NULL

      for (mv in moves) {
        dfMv <- dfStats %>%
          dplyr::select(snr, starts_with(mv), N) %>%
          dplyr::rename_(.dots = setNames(names(.), gsub(concat(mv, "\\.", b, "\\."), "", names(.)))) %>%
          dplyr::mutate(move = mv)
        dfObs <- rbind(dfObs, dfMv)
      }

      dfObs$obs <- b
      dfCh <- rbind(dfCh, dfObs)
    }

    dfCh$exp <- channel
    dfCh
  }

  # collect the results over each expected match base
  dfErr = list()
  
  # Check if the input condition names match the number of csv files
  readcondition = unlist(strsplit(args$conditionNames, ","))
  if (length(readcondition) == 0) {
    readcondition = rep(NA, length(args$input))
    for (i in 1:length(args$input)) {
      readcondition[i] = gsub(".csv","",as.character(args$input[i]))
    }
  } else if (length(readcondition) != length(args$input)) {
    stop("The input csv files and condition names have different numbers.")
  }
  
  for (i in 1:length(args$input)) {
    dfErr[[i]] = NA
    for (b in bases) {
      dfErr[[i]] <- rbind(dfErr[[i]], massage(errormode[[i]], b))
      dfErr[[i]] = dfErr[[i]][c(2:nrow(dfErr[[i]])),]
    }
    # make sure things are factors and the appropriate levels
    levels(dfErr[[i]]$snr) <- head(breaks, length(levels(dfErr[[i]]$snr)))
    dfErr[[i]]$move <- as.factor(dfErr[[i]]$move)
    dfErr[[i]]$exp <- as.factor(dfErr[[i]]$exp)
    dfErr[[i]]$obs <- as.factor(dfErr[[i]]$obs)
    dfErr[[i]] <- as.data.frame(dfErr[[i]])
    row.names(dfErr[[i]]) <- seq.int(nrow(dfErr[[i]]))
    # Add Condition name from the input file names
    dfErr[[i]]$Condition = readcondition[i]
  }
  # write the data
  dfErr = do.call(rbind, dfErr)
  write.csv(dfErr, file.path(output_path, "FishboneSnrBinnedSummary.csv"))

  ## WRITE THE PLOTS ##
  # filter by min number of samples in each SNR bin
  dfErr_ <- dfErr %>% filter(N >= minSample)
  loginfo("filtered %d of %d samples", nrow(dfErr) - nrow(dfErr_), nrow(dfErr))
  if (nrow(dfErr_) == 0) {
    stop("You have filtered out all of your data and need to increase the Min Sample!")
  }

  t <- function(mv) ifelse(mv == "Match", "Mismatch", as.character(mv))

  dfErr_ <- dfErr_ %>%
    dplyr::mutate(exp_ = concat("NextBase - ", exp), obs_ = concat(t(move), " - ", obs))
  dfErr_$exp_ <- as.factor(dfErr_$exp_)
  dfErr_$obs_ <- as.factor(dfErr_$obs_)

  limits <- function(df) {
    m <- floor(min(df$mu - df$ci) * 50) / 50
    M <- ceiling(max(df$mu + df$ci) * 50) / 50
    c(m, M)
  }

  labelFn <- function(x) { sprintf("%0.2f", x) }
  breaksFn <- function(x) { seq(x[[1]], x[[2]], by = 0.02)}

  dfIns <- dfErr_ %>% filter(move == "Insert")
  ylim <- limits(dfIns)
  breaks <- breaksFn(ylim)
  ggplot(dfIns, aes(x = as.numeric(as.character(snr)), y = mu, group = Condition, colour = Condition)) +
    geom_point(aes(colour = Condition)) + geom_line(aes(colour = Condition)) + geom_errorbar(aes(ymin = mu - ci, ymax = mu + ci, colour = Condition), width = 0.1, position = pd) +
    xlim(0, 20) + scale_y_continuous(limits = ylim, breaks = breaks) + 
    labs(x = "SNR by Outcome", y = "HMM Insertion Error") +
    facet_grid(exp_ ~ obs_) +
    plTheme + clScale + themeTilt
  ggsave(file.path(output_path, "FishbonePlot_Insertion.png"), width = 1600/dpi, height = 1200/dpi, units = "in")

  dfMM <- dfErr_ %>% filter(move == "Match" & obs != exp)
  ylim <- limits(dfMM)
  breaks <- breaksFn(ylim)
  ggplot(dfMM, aes(x = as.numeric(as.character(snr)), y = mu, group = Condition, colour = Condition)) +
    geom_point(aes(colour = Condition)) + geom_line(aes(colour = Condition)) + geom_errorbar(aes(ymin = mu - ci, ymax = mu + ci, colour = Condition), width = 0.1, position = pd) +
    xlim(0, 20) + scale_y_continuous(limits = ylim, breaks = breaks) +
    labs(x = "SNR by Outcome", y = "HMM Mismatch Error") +
    facet_grid(exp_ ~ obs_) +
    plTheme + clScale + themeTilt
  ggsave(file.path(output_path, "FishbonePlot_Mismatch.png"), width = 1600/dpi, height = 1200/dpi, units = "in")

  dfDel <- dfErr_ %>% filter(move == "Dark" | move == "Merge")
  ylim <- limits(dfDel)
  breaks <- breaksFn(ylim)
  ggplot(dfDel, aes(x = as.numeric(as.character(snr)), y = mu, colour = Condition, group = Condition)) +
    geom_point(aes(colour = Condition)) + geom_line(aes(colour = Condition)) + geom_errorbar(aes(ymin = mu - ci, ymax = mu + ci, colour = Condition), width = 0.1, position = pd) +
    xlim(0, 20) + scale_y_continuous(limits = ylim, breaks = breaks) +
    labs(x = "SNR by Event", y = "HMM Deletion Error") +
    facet_grid(exp_ ~ move) +
    plTheme + clScale + themeTilt
  ggsave(file.path(output_path, "FishbonePlot_Deletion.png"), width = 800/dpi, height = 1200/dpi, units = "in")

  dfErr
}

output_path <- normalizePath(args$output)

dir.create(output_path, showWarnings = F)

# Read multiple input csv files (at least one)
df <- list()
for (i in 1:length(args$input)) {
    df[[i]] <- read.csv(args$input[i])
  }

res <- makeFishbonePlots(df, output_path, args$minSample)
